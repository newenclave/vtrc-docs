/* UTF8 */

Библиотека предназначена для реализации серверов и клиентов, поддерживающих RPC протокол (vtrc). 

Язык разработки: С++.

Сторонние библиотеки: Boost (http://boost.org/); 
                      Google Protocol Buffers (https://code.google.com/p/protobuf/) далее просто Protobuf

##Основные возможности:

 * Поддержка транспорта: TCP (для IPv4 и IPv6), Unix domain sockets ("POSIX Local IPC Sockets"; для систем, поддерживающих стандарт POSIX), Windows named pipes (для систем семейства Windows). 
	
 * Декларативность: библиотека Protocol Buffers позволяет легко описать сообщения и интерфейс RPC.

 * Обратная совместимость протокола: Protobuf обеспечивает обратную совместимость, т.е. совместимость с предыдущими версиями протокола. Новые поля сообщения будут игнорироваться старыми серверами, как и удаленные старые.

 * Масштабируемость: Использование Boost.Asio позволяет масштабировать как серверую сторону, так и клиентскую. 

##Также библиотека позволяет:
    
 * контролировать количество активных вызовов клиента
 * устанавливать максимальный размер сообщения как для конкретной серверной точки, так и для каждого клиента в отдельности на стадии инициализации соединения 
 * разнести обработку системных событий ввода-вывода и выполнение процедур по разным диспетчерам, либо использовать один. 
 * задать для каждого конкретного вызова, либо группы вызовов (service, в терминах Protobuf) таймаут ожидания. 


##Поддерживаемые методы удаленных вызовов. 

Вызовы делятся на 2 типа: с ожиданием результата (**CALL**) и без ожидания (**EVENT**). 
Далее по тексту: "*сторона A*" — сторона, инициализировавшая выполнение процедуры; "*сторона B*" — сторона, выполняющая процедуру. *Стороной A* (как и *стороной B*) может выступать как клиентская, так и серверная часть.

Первый случай:

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-direct.png" />

*Сторона A* будет ждать ответа с результатом от *стороны B*. Ответ может содержать результат работы или ошибку, которая произошла при выполнении. Стоит отметить, что *сторона A* может указать *стороне B* то, что она не заинтересована в получении результата, а нужен только факт окончания выполнения. В этом случае сторона B отправит сообщение с пустым результатом, либо с ошибкой, если что-то случилось. Ожидание может быть сброшено по истечению заданного времени (timeout)

Случай второй: 

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-event.png" /> 

*Cторона A* просто отправляет сообщение с запросом на выполнение процедуры, но не ждет результат. *Сторона B*, в этом случае, не будет отправлять ответ с результатом работы. 

Кроме того.
-----------

Вызов может быть сделан при активном выполнении вызова (**CALLBACK**). То есть ситуация: 
*сторона А* просит у *стороны B* сделать **вызов B1**, в это время *сторона B* может обратиться к *стороне А* с просьбой выполнить **вызов A1** и, дождавшись ответа со *стороны А* продолжать выполнение **вызов B1**, после чего вернуть результат *стороне А*. Вызов со *стороны B* может быть как **CALL** (то есть с ожиданием), либо **EVENT** (без ожидания)

Ниже приведена схема всего этого безобразия

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-back.png" /> 




