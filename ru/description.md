/* UTF8 */

Библиотека предназначена для реализации серверов и клиентов, поддерживающих RPC протокол (vtrc). 

Язык разработки: С++.

Сторонние библиотеки: Boost (http://boost.org/); 
                      Google Protocol Buffers (https://code.google.com/p/protobuf/) далее просто Protobuf

##Основные возможности:

 * Поддержка транспорта: TCP (для IPv4 и IPv6), Unix domain sockets ("POSIX Local IPC Sockets"; для систем, поддерживающих стандарт POSIX), Windows named pipes (для систем семейства Windows). 
	
 * Декларативность: библиотека Protobuf позволяет легко описать сообщения и интерфейс RPC.

 * Обратная совместимость протокола: Protobuf обеспечивает обратную совместимость, т.е. совместимость с предыдущими версиями протокола. Новые поля сообщения будут игнорироваться старыми серверами, как и удаленные старые.

 * Масштабируемость: Использование Boost.Asio позволяет масштабировать как серверую сторону, так и клиентскую. 

##Также библиотека позволяет:
    
 * контролировать количество активных вызовов клиента
 * устанавливать максимальный размер сообщения как для конкретной серверной точки, так и для каждого клиента в отдельности на стадии инициализации соединения 
 * разнести обработку системных событий ввода-вывода и выполнение процедур по разным диспетчерам, либо использовать один. 
 * задать для каждого конкретного вызова, либо группы вызовов (service, в терминах Protobuf) таймаут ожидания. 


##Поддерживаемые методы удаленных вызовов. 

Вызовы делятся на 2 типа: с ожиданием результата (далее **CALL**) и без ожидания (далее **EVENT**).

Далее по тексту: "*сторона A*" — сторона, инициализировавшая выполнение процедуры; "*сторона B*" — сторона, выполняющая процедуру. *Стороной A* (как и *стороной B*) может выступать как клиентская, так и серверная часть.

Первый случай:

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-direct.png" />

*Сторона A* будет ждать ответа с результатом от *стороны B*. Ответ может содержать результат работы или ошибку, которая произошла при выполнении. Стоит отметить, что *сторона A* может указать *стороне B* то, что она не заинтересована в получении результата, а нужен только факт окончания выполнения. В этом случае сторона B отправит сообщение с пустым результатом, либо с ошибкой, если что-то случилось. Ожидание может быть сброшено по истечению заданного времени (timeout)

Случай второй: 

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-event.png" /> 

*Cторона A* просто отправляет сообщение с запросом на выполнение процедуры, но не ждет результат. *Сторона B*, в этом случае, не будет отправлять ответ с результатом работы. 

Кроме того.
-----------

Вызов может быть сделан при активном выполнении вызова другой стороны (ууф) (**CALLBACK**). То есть ситуация: 
*сторона А* просит у *стороны B* сделать **вызов B1**, в это время *сторона B* может обратиться к *стороне А* с просьбой выполнить **вызов A1** и, дождавшись ответа со *стороны А* продолжать выполнение **вызова B1**, после чего вернуть результат *стороне А*. Вызов со *стороны B* может быть как **CALL** (то есть с ожиданием), так и **EVENT** (без ожидания)

Ниже приведена схема всего этого безобразия

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-back.png" /> 

И схема работы, когда *сторона B* отправляет **EVENT** из вызова *стороны А*

<img src="https://raw.githubusercontent.com/newenclave/vtrc-docs/master/img/call-call-event.png" /> 


Вышеозначенная схема работает тогда и только тогда, когда *сторона А* выполняет **CALL**, но не **EVENT**. Иными словами, для того, чтобы сделать вызов, который должен быть выполнен в контексте вызова другой стороны, нужен контекст, а у **EVENT** контекста нет.

В случае же, когда *сторона А* выполняет **EVENT**, вызов со *стороны B* подчиняется уже общим правилам и будет вызван для исполнения диспетчером в свободном потоке. 

*Сторона B* может попросить *сторону А* выполнить процедуру в другом потоке даже тогда, когда *сторона А* выполняет **CALL**. 

Итого (соберем всё в кучу): Вызовы могут быть с ожиданием или без, вызовы могут быть сделаны в контексте других вызовов, либо вне их.

А там, где есть вызов из другого вызова есть рекурсия. Поэтому в библиотеке предусмотрен механизм защиты от переполнения стека. Максимальная глубина вызовов, по-умолчанию, установлена в 64 (см ниже.). И если какая-то сторона попытается сделать вызов дольше, получит ошибку "overflow". 
Значение этого параметра можно менять.

Значение 64 говорит о том, что *максимальная длина цепочки* вызовов не может превышать 64. То есть допустим на стороне сервера есть вызов *call1*, а на стороне клиента *call2*. Тогда при схеме 

    C(call1) -> S(call2) -> C(call1)  
    то есть клиент вызывает call1, ждет результата, 
    в это время сервер вызывает call2 и тоже ждет результата,
    а клиент снова вызывает call1

длина цепочки будет равна 3.

###Использование в примерах:


